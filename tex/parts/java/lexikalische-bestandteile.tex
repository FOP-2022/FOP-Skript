\subsection{Datentypen}
	\implements{Datentypen}{datentypen}{Java}
	
	Java ist eine statisch Typisierte Sprache, das heißt der Typ einer Variable muss jederzeit angegeben werden und dem Compiler bekannt sein. Es ist nicht möglich, eine Variable nacheinander für zum Beispiel Zahlen und Zeichenketten zu verwenden.
	
	In Java existieren viele Datentypen, die in zwei Kategorien unterteilt werden können:
	\begin{itemize}
		\item Primitive Datentypen
		\item Objektreferenzen
	\end{itemize}
	
	\paragraph{Primitive Datentypen}
		Einer der Unterschiede zwischen primitiven Datentypen und Objektreferenzen ist, dass Daten, welche in primitiven Datentypen gespeichert sind, mit Pass-by-Value weitergegeben werden. Das bedeutet, die Daten werden bei einer Übergabe an die Methode kopiert und Änderungen an den Daten an einer Stelle wirken sich nicht auf andere Stelle aus. Außerdem sind ist die Anzahl an primitiven Datentypen begrenzt und die Datentypen sind von vornherein festgelegt. Ferner gibt es große Unterschiede bei der Behandlung von Konstanten, die wir später betrachten werden. \todo{Primitive vs. Objekte: Konstanten} Als ersten Anhaltspunkt eignet sich, dass primitive Datentypen mit einem kleinen Buchstaben und Objektreferenztypen mit einem großen Buchstaben beginnen.
		
		Es existieren folgende primitive Datentypen:
		\begin{table}[H]
			\centering
			\begin{tabular}{l | l | l | l}
				Schlüsselwort       & Typ            & Beschreibung               & Wertebereich                                                      \\ \hline
				\lstinline|byte|    & Ganzzahl       & Vorzeichenbehaftet, 8 Bit  & \( -(2 ^ { 7}) \) bis \( 2 ^ { 7} - 1 \)                          \\
				\lstinline|short|   & Ganzzahl       & Vorzeichenbehaftet, 16 Bit & \( -(2 ^ {15}) \) bis \( 2 ^ {15} - 1 \)                          \\
				\lstinline|int|     & Ganzzahl       & Vorzeichenbehaftet, 32 Bit & \( -(2 ^ {31}) \) bis \( 2 ^ {31} - 1 \)                          \\
				\lstinline|long|    & Ganzzahl       & Vorzeichenbehaftet, 64 Bit & \( -(2 ^ {63}) \) bis \( 2 ^ {63} - 1 \)                          \\
				\lstinline|float|   & Fließkommazahl & einfache Genauigkeit       & \( 1,4 \cdot 10 ^ {-45} \) bis \( \approx 3,4 \cdot 10 ^ {38} \)  \\
				\lstinline|double|  & Fließkommazahl & doppelte Genauigkeit       & \( 4,9 \cdot 10 ^ {324} \) bis \( \approx 1,8 \cdot 10 ^ {308} \) \\
				\lstinline|char|    & Charakter      & Unicode-Code, 16 Bit       & \( 0 \) bis \( 2 ^ {16} - 1 \)                                    \\
				\lstinline|boolean| & Wahrheitswert  &                            & \texttt{true}/\texttt{false}
			\end{tabular}
			\caption{Liste der primitiven Datentypen in Java}
		\end{table}
		
		Hierbei fällt auf, dass es in Java keinen eingebauten Datentyp für vorzeichenfreie Zahlen (\enquote{unsigned}) gibt. Dies kann bei der Verarbeitung von Binärdaten (beispielsweise bei Netzwerkkommunikation) zu Fehlern führen.
	% end
	
	\paragraph{Objektreferenzen}
		Neben primitiven Datentypen gibt es noch die Objektreferenzen. Diese verhalten sich anders als primitive Datentypen, wobei uns vor allem die folgenden Unterschiede auffallen:
		\begin{itemize}
			\item Es gibt als einziges \enquote{echtes} Literal den Wert \lstinline|null|, der aussagt, dass die Objektreferenz kein Objekt referenziert. Jegliche Methodenaufrufe auf dieser Referenz brechen mit einer \lstinline|NullPointerException| ab. Deshalb muss vor jedem Zugriff auf eine solche Referenz geprüft werden, ob sie ungleich \lstinline|null| ist.
			\item Werden Objektreferenzen als Parameter übergeben, so wird hierbei ausschließlich die Referenz übergeben und auf das gleiche Objekt referenziert (Pass-by-Reference). Das bedeutet, eine Änderung an dem Objekt an einer Stelle kann sich an beliebig vielen anderen Stellen auswirken.
		\end{itemize}
		Wir werden uns Objektreferenzen im Abschnitt \refImpl{oop}{Java} über objektorientierte Programmierung in Java nochmals genauer anschauen.
	% end
	
	\paragraph{Sonderfall \lstinline|String|}
		Ein \lstinline|String| ist eine Objektreferenz, kann allerdings in manchen Bereichen als ein primitiver Datentyp angesehen werden. Beispielsweise existieren, wir wir weiter unten noch sehen werden, Literale für diesen Datentyp, welche implizit ein Objekt erzeugen. Auch scheint ein String mit Pass-by-Value übergeben zu werden, da ein String nicht veränderbar ist.
		
		Insgesamt existieren folgende Unterschiede:
		\begin{itemize}
			\item Ein String ist \textit{immutable}, das heißt nicht veränderlich.
			\item Dadurch scheint es, als wird ein String Pass-by-Value übergeben.
			\item Bei Konstanten wird ein String als primitiver Typ angesehen und gleich behandelt.
			\item Es gibt eine syntaktische Form, String-Literale auszudrücken.
			\item Trotz allem ist es möglich, einem String den Wert \lstinline|null| zuzuweisen. Dies ist gleichermaßen praktisch wie nervig.
		\end{itemize}
	% end
% end

\subsection{Literale}
	\implements{Literalen}{literale}{Java}
	
	In Java gibt es Schreibweisen für Literale für alle Datentypen, wobei die Erstellung von Objekten einen Sonderfall darstellt und nicht vollständig als Literal bezeichnet werden kann (es können zwar alle Argumente fest im Code stehen, das Objekt selbst wird allerdings erst zur Laufzeit erstellt).
	
	In der folgenden Tabelle sind sämtliche syntaktische Methoden zu Definition von Literalen gelistet:
	\begin{table}[H]
		\centering
		\begin{tabular}{l | l}
			\textbf{Datentyp} & \textbf{Schreibweise}                          \\ \hline
			\texttt{byte}     & \texttt{123}, \texttt{-123}                    \\
			\texttt{short}    & \texttt{1234}, \texttt{-1234}                   \\
			\texttt{int}      & \texttt{12345}, \texttt{-12345}                 \\
			\texttt{long}     & \texttt{123456L}, \texttt{123456L}               \\
			\texttt{float}    & \texttt{12.34F}, \texttt{0.34F}/\texttt{.34F}  \\
			\texttt{double}   & \texttt{123.456}, \texttt{0.456}/\texttt{.456} \\
			\texttt{char}     & \texttt{'a'}                                   \\
			\texttt{boolean}  & \texttt{true}, \texttt{false}                  \\
			\texttt{String}   & \texttt{"Hello, World!"}                       \\
			\texttt{Object}   & \texttt{null}
		\end{tabular}
	\end{table}
	\begin{itemize}
		\item \texttt{String} ist hier kein primitiver Datentyp, das heißt mit einem String-Literal wird auch immer ein neues Objekt erzeugt.
		\item Das Literal \texttt{null} für \texttt{Object} ist allgemein anwendbar, wenn mit Objekten gearbeitet wird. Allerdings kann dies zu unerwarteten \textit{\texttt{NullPointerExceptions}} führen, welche wir später noch eingehend betrachten werden.
	\end{itemize}
	
	Bei Literalen von Zahlen gibt es außerdem folgende Besonderheiten:
	\begin{itemize}
		\item Bei einem \texttt{float}-Literal muss ein \enquote{\texttt{F}} am Ende des Literals angehängt werden, damit das Literal als \texttt{float} und nicht als \texttt{double} interpretiert wird. Die Groß-/Kleinschreibung ist irrelevant.
		\item Bei einem \texttt{long}-Literal kann ein \enquote{\texttt{L}} am Ende des Literals angehängt werden, damit das Literal als \texttt{long} und nicht als \texttt{int} interpretiert wird. Die Groß-/Kleinschreibung ist irrelevant, aufgrund der Ähnlichkeit von \enquote{\texttt{l}} und \enquote{\texttt{1}} wir allerdings ein großes \enquote{\texttt{L}} empfohlen.
		\item Bei allen Ganzzahlen (\texttt{byte}, \texttt{short}, \texttt{int}, \texttt{long}) können die Zahlen mit den Zahlensystemen Binär, Oktal, Dezimal und Hexadezimal eingegeben werden, wobei Dezimal sinnvollerweise der Standard ist. Zur Nutzung hiervon müssen den Werten bestimmte Zeichenketten vorangestellt werden. Dies sind \texttt{0b} für Binär, \texttt{0} für Oktal, nichts für Dezimal und \texttt{0x} für Hexadezimal. \\ Das heißt, die folgenden Literale sind äquivalent:
			\begin{itemize}
				\item \texttt{0b101010}
				\item \texttt{052}
				\item \texttt{42}
				\item \texttt{0x2A}
			\end{itemize}
			Wobei auch hier die Groß-/Kleinschreibung irrelevant ist, für den Prefix allerdings die Kleinschreibung und für die Zahl die Großschreibung empfohlen wird.
	\end{itemize}
	
	\warning{Wird bei Zahlen eine \texttt{0} vorangestellt, wird die Zahl Oktal interpretiert! Das heißt es gilt \texttt{010 \(\neq\) 10}.}
	
	\paragraph{Escape-Sequenzen}
		Escape-Sequenzen werden innerhalb eines Strings mit einem Backslash (\textbackslash) eingeleitet und bestehen in den meisten Fällen auf einem Zeichen.
		
		In Java sind folgende Escape-Sequenzen verfügbar:
		\begin{table}[H]
			\centering
			\begin{tabular}{c | l}
				\textbf{Escape-Sequenz} & \textbf{Repräsentiertes Zeichen} \\ \hline
				\lstinline|\t|          & Tab.                             \\
				\lstinline|\b|          & Backspace.                       \\
				\lstinline|\n|          & New line.                        \\
				\lstinline|\r|          & Carriage Return.                 \\
				\lstinline|\f|          & Formfeed.                        \\
				\lstinline|\'|          & Single quote.                    \\
				\lstinline|\"|          & Double quote.                    \\
				\lstinline|\\|          & Backslash.
			\end{tabular}
			\caption{Java: Escape-Sequenzen}
		\end{table}
	% end
% end

\subsection{Schlüsselwörter}
	\implements{Schlüsselwörtern}{keywords}{Java}
	
	In Java existieren folgende Schlüsselwörter (kursiv geschriebene Themen werden wir nicht ausführlicher betrachten):
	\begin{description}
        \item[\texttt{abstract}] Markiert eine\dots
	        \begin{description}
	        	\item[Klasse] das heißt, diese kann abstrakte Methoden enthalten.
	        	\item[Methode] die von Unterklassen implementiert werden muss.
	        \end{description}
        \item[\texttt{continue}] Fährt in einer Schleife mit dem nächsten Element fort.
        \item[\texttt{for}] Leitet eine for-Schleife ein.
        \item[\texttt{new}] Operator zur Erstellung eines neuen Objektes einer Klasse.
        \item[\texttt{switch}] Leitet eine switch-Anweisung ein.
        \item[\texttt{assert}] Legt bestimmte Bedingungen fest, die für Parameter gelten müssen. Gelten diese nicht, wird ein Fehler ausgelöst.
        \item[\texttt{default}]
	        \begin{itemize}
	        	\item Default-Fall in einer switch-Anweisung.
	        	\item Definition einer Default-Methode innerhalb eines Interfaces.
	        	\item \textit{Definition des Default-Wertes einer Methode in einer Annotation}
	        \end{itemize}
        \item[\texttt{if}] Leitet eine if-Verzweigung ein.
        \item[\texttt{package}] Definition des Packages einer Klasse.
        \item[\texttt{synchronized}] Markiert eine Methode oder einen Codeblock als synchron, das heißt es kann maximal ein Thread zur gleichen Zeit die Methode \enquote{betreten}.
        \item[\texttt{boolean}] Datentyp.
        \item[\texttt{do}] Leitet eine do-while-Schleife ein.
        \item[\texttt{goto}] Reserviert. Löst ausschließlich einen Compilefehler aus.
        \item[\texttt{private}] Markiert eine Klasse, einen Konstruktor, eine Methode oder ein Attribut als privat.
        \item[\texttt{this}] Referenz auf die Instanz des aktuellen Objektes.
        \item[\texttt{break}] Bricht die Ausführung einer Schleife ab.
        \item[\texttt{double}] Datentyp.
        \item[\texttt{implements}] Implementiert ein Interface.
        \item[\texttt{protected}] Markiert eine Klasse, einen Konstruktor, eine Methode oder ein Attribut als protected.
        \item[\texttt{throw}] Wirft eine Instanz einer Exception.
        \item[\texttt{byte}] Datentyp.
        \item[\texttt{else}] Leitet einen else-Block ein.
        \item[\texttt{import}] Importiert eine Klasse/Methode aus einem anderen Paket.
        \item[\texttt{public}]  Markiert eine Klasse, einen Konstruktor, eine Methode oder ein Attribut als public.
        \item[\texttt{throws}] Definiert, dass ein Konstruktor/eine Methode eine bestimmte Exception werfen kann.
        \item[\texttt{case}] Leitet einen Fall eines switch-Ausdruckes ein.
        \item[\texttt{enum}] Leitet die Definition eines Enums ein.
        \item[\texttt{instanceof}] Operator zum Prüfen, ob eine Instanz eine Instanz einer anderen Klasse ist.
        \item[\texttt{return}] Gibt einen Wert zurück und bricht die Ausführung der Methode/des Konstruktors ab.
        \item[\textit{\texttt{transient}}] \textit{Definiert, dass ein bestimmte Attribut einer Instanz nicht mit serialisiert wird.}
        \item[\texttt{catch}] Leitet einen catch-Block ein.
        \item[\texttt{extends}]
	        \begin{description}
	        	\item[Klasse] Erweitert eine bestehende (möglicherweise abstrakte) Klasse.
	        	\item[Interface] Erweitert ein bestehendes Interface.
	        \end{description}
        \item[\texttt{int}] Datentyp.
        \item[\texttt{short}] Datentyp.
        \item[\texttt{try}] Leitet einen try-Block ein.
        \item[\texttt{char}] Datentyp.
        \item[\texttt{final}]
	        \begin{description}
	        	\item[Klasse] Die Klasse ist nicht vererbbar.
	        	\item[Methode] Die Methode ist nicht überschreibbar.
	        	\item[Variable] Die Variable ist nur einmal zuweisbar.
	        \end{description}
        \item[\texttt{interface}] Leitet die Definition eines Interfaces ein.
        \item[\texttt{static}] Markiert eine innere Klasse, eine Methode oder ein Attribut als statisch.
        \item[\texttt{void}] \enquote{Datentyp} als Platzhalter für \enquote{Nichts}.
        \item[\texttt{class}] Leitet die Definition einer Klasse ein.
        \item[\texttt{finally}] Leitet einen finally-Block ein.
        \item[\texttt{long}] Datentyp.
        \item[\textit{\texttt{strictfp}}] \textit{Legt fest, dass innerhalb einer Methode/einer Klasse nur strikte mathematische Operationen verwendet werden, sodass diese nicht optimiert werden sollen (es wird sich strikt an den Standard gehalten).}
        \item[\textit{\texttt{volatile}}] \textit{Markiert ein Attribut, sodass Modifikationen an diesem atomar durchgeführt werden und für andere Threads direkt sichtbar sind.}
        \item[\texttt{const}] Reserviert. Löst ausschließlich einen Compilefehler aus.
        \item[\texttt{float}] Datentyp.
        \item[\textit{\texttt{native}}] \textit{Markiert die Implementierung einer Methode als nativ, das heißt, die Implementierung liegt in nativem Code (C/C++) vor. Siehe JNI (Java Native Interface).}
        \item[\texttt{super}] Referenz auf die Instanz der Oberklasse des aktuellen Objektes.
        \item[\texttt{while}] Leitet eine while-Schleife ein.
	\end{description}
	
	Die genaue Bedeutung der obigen Schlüsselwörter werden wir in den jeweiligen Kapiteln genauer betrachten.
% end

\subsection{Bezeichner und Konventionen}
	\implements{Bezeichnern und Namenskonventionen}{identifier}{Java}
	
	In Java können Zeichenketten als Bezeichner gelten, wenn sie folgenden Bedingungen genügen:
	\begin{itemize}
		\item Sie bestehen nur aus \texttt{a} bis \texttt{z}, \texttt{0} bis \texttt{9}, \texttt{\_} oder \texttt{\$}.
		\item Sie beginnen nur mit \texttt{a} bis \texttt{z}, \texttt{\_} oder \texttt{\$}.
	\end{itemize}
	
	Zur Benennung sind außerdem folgende Konventionen zu empfehlen:
	\begin{itemize}
		\item Namen von Klassen beginnen mit einem Großbuchstaben.
		\item Namen von Methoden/Parametern/Variablen/etc. beginnen mit einem Kleinbuchstaben.
		\item Namen von Klassen sollen Subjekte und Objekte sein. Beispiel: \enquote{\texttt{User}}
		\item Namen von Methoden sollen mit einem Verb beginnen. Beispiel: \enquote{\texttt{generateAccessToken}}
	\end{itemize}
	
	\info{Die oben Bedingungen, wann eine Zeichenkette als Bezeichner dienen kann, stellen Vereinfachungen dar. Streng genommen können alle Zeichen verwendet werden, für die die Methoden \texttt{Character.isJavaIdentifierStart(char)} bzw. \texttt{Character.isJavaIdentifierPart(char)} den Wert \texttt{true} ergeben. Damit \textit{wären} auch Bezeichner wie \enquote{\texttt{\(\Delta\Psi\)}} möglich.}
% end

\subsection{Operatoren}
	\implements{Operatoren}{lexOperatoren}{Java}
	
	In Java existieren die folgenden Operatoren, die genaue Bedeutung werden wir im Abschnitt \refImpl{operatoren}{Java} behandeln:
	\begin{table}[H]
		\centering
		\begin{tabular}{l | l}
			Kategorie & Ausprägungen \\
			\hline
			Arithmetische Verknüpfungen & \texttt{*}, \texttt{/}, \texttt{\%}, \texttt{+}, \texttt{-} \\
			Unäre Arithmetik            & \texttt{expr++}, \texttt{expr--}, \texttt{++expr}, \texttt{--expr}, \texttt{+expr}, \texttt{-expr} \\
			Logik                       & \texttt{!}, \texttt{\&\&}, \texttt{||}, \texttt{\textasciicircum}, \texttt{?:} \\
			Bitweise Logik              & \texttt{\textasciitilde}, \texttt{\&}, \texttt{|}, \texttt{\textasciicircum} \\
			Verschiebung (Shift)        & \texttt{<{}<}, \texttt{>{}>}, \texttt{>{}>{}>} \\
			Vergleiche                  & \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{==}, \texttt{!=}, \texttt{instanceof} \\
			Zuweisungen                 & \texttt{=}, \texttt{+=}, \texttt{-=}, \texttt{*=}, \texttt{/=}, \texttt{\%=}, \texttt{\textasciicircum=}, \texttt{|=}, \texttt{<{}<=}, \texttt{>{}>=}, \texttt{>{}>{}>=} \\
		\end{tabular}
		\caption{Java: Operatoren}
	\end{table}
% end

\subsection{Strukturierung des Codes, Packages und Imports}
	\implements{Paketen und Code-Strukturierung}{namespaces}{Java}
	
	\subsubsection{Kommentare}
		Es gibt drei verschiedene Arten von Kommentaren in Java:
		\begin{itemize}
			\item Einzeilige Kommentare \\ Der Kommentar ist nur in der aktuellen Zeile gültig.
			\item Blockkommentare \\ Der Kommentar ist gültig, bis der Kommentar explizit beendet wird (auch über Zeilenumbrüche hinweg).
			\item Javadoc \\ Dies ist eine besondere Form eines Blockkommentars, der so nur vor einer Methode, einem Feld oder einem Typ stehen kann (und, um es ganz genau zu nehmen, vor der \lstinline|package|-Deklaration in einer Datei \texttt{package-info.java}). Diese besondere Form von Kommentaren wird genutzt, um den Code zu Dokumentieren und anschließend eine HTML-Dokumentation daraus zu generieren. Wir werden dies im Abschnitt \refImpl{doku}{Java} über Javadoc intensiver anschauen.
		\end{itemize}
	% end
	
	\subsubsection{Whitespaces}
		Jegliche Whitespaces (Tab, Zeilenumbruch, Leerzeichen) sind in Java optional und dienen nur der Strukturierung des Codes. Trotz dass dies überflüssig ist, empfiehlt es sich, wenn wir unseren Code einrücken, gezielt Zeilenumbrüche setzen und so unseren Code lesbar machen.
	% end
	
	\subsubsection{Klammerung}
		In Java werden jegliche verfügbaren Klammern genutzt ((), {}, [], <>). Sie haben die folgenden Zwecke:
		\begin{description}
			\item[\texttt{()}] Klammerung von Ausdrücken (um die Operatorenpräzedenz festzulegen), Aufrufen von Methoden/Konstruktoren, Notwendig bei If-Ausdrücken, Switch-Case und Schleifen.
			\item[\texttt{\{\}}] Kennzeichnung von Codeblöcken (Klassen-/Methodendefinition, If-Ausdrücke, Schleifen, Switch-Case, \dots).
			\item[\texttt{[]}] Zugriff auf die Elemente eines Arrays und Erstellung von Arrays.
			\item[\texttt{<>}] Vergleichsoperatoren und Generics.
		\end{description}
	% end
	
	\subsubsection{Packages und Imports}
		Als übergeordnete Strukturierung unserer Klassen existiert das Konstrukt von \textit{Packages}, mit denen Klassen gruppiert und somit logisch zusammengefasst werden können. Beispielsweise können wir alle Klassen, die mit dem Zugriff auf eine Datenbank zu tun haben in ein Package \texttt{database} legen, und die Klassen, die mit dem User Interface zu tun haben in ein Package \texttt|ui|. Der Name eines Packages muss ein gültiger Bezeichner sein. Um eine Klasse in einem Package abzulegen, muss die Klasse zum einen mit der Zeile \lstinline|package /* Packagename */;| starten und außerdem im korrekten Ordner liegen (das heißt eine Klasse im Package \texttt{ui} muss in einem Ordner \texttt{ui} liegen).
		
		Damit entsteht eine logische Trennung und das Projekt wird übersichtlicher. Der \textit{voll-qualifizierte Klassen} ist dann der Name der Klasse mit dem vorangestellten Package-Namen. Hierdurch werden Kollisionen in der Klassenbenennung vermieden. Beispiel: Unsere Klasse \texttt{Connection} liegt im Package \texttt{database}. Dann ist der voll-qualifizierte Name dieser Klasse \texttt{database.Connection}. Nutzen wir innerhalb einer Klasse eine andere Klasse, die nicht im selben Package und nicht im Package \texttt{java.lang} liegt, so müssen wir entweder den voll-qualifizierten Klassennamen bei jeder Verwendung angeben oder die Klasse mit dem Ausdruck \lstinline|import /* Voll-qualifizierter Klassenname */;| importieren. Dann können wir die Klasse überall nutzen, als wäre sie im gleichen Package. Standardmäßig sind alle Klassen aus \lstinline{java.lang} importiert.
		
		Um Packages von Unterpackages zu trennen, können wir Punkte innerhalb des Package-Namen nutzen. Somit können wir beispielsweise Klassen, die mit der Datenbank und konkret mit MySQL zu tun haben, in ein Package \lstinline{database.mysql} legen.
		
		\paragraph{Konvention}
			Zur Vermeidung von Kollisionen ist es üblich, allen Packages innerhalb eines Projektes den umgekehrten Namen der Domain voranzustellen, für die das Projekt entwickelt wird (Bindestriche oder andere nicht-Java-konforme Zeichen werden dabei durch einen Unterstrich ersetzt, siehe §3.8 Java-Spezifikation). Danach folgt der Projektname.
			
			Bei der Entwicklung von Nabla für das Fachgebiet Algorithmik am Fachbereich Informatik an der TU Darmstadt sollte also der Packagename \lstinline|de.tu_darmstadt.informatik.algo.nabla| vorangestellt werden.
		% end
	% end
% end
