Schauen wir uns nun an, wie man Dinge in Java tut, also wie wir Anweisungen und Ausdrücke formulieren können.

\subsection{Variablen}
	\implements{Variablen}{variablen}{Java}
	
	Die allgemeine Syntax zur Deklaration einer Variablen ist:
	\begin{figure}[H]
		\centering
		\lstinline|<modifier> <typ> <name>;|
	\end{figure}
	Dabei ist \texttt{<modifier>} eine Reihe von Schlüsselwörtern, welche das Verhalten der Variablen modifizieren (genannt \enquote{Modifier}). Diese werden wir uns weiter unten genau anschauen. \texttt{<typ>} ist der Datentyp der Variablen (dies kann ein primitiver Datentyp aber auch ein Referenztyp sein). Der Name der Variablen wird mit \texttt{<name>} festgelegt.
	
	\subsubsection{Modifier}
		Für eine lokale Variable (das heißt eine Variable innerhalb eines Codeblocks oder als Parameter) existiert ausschließlich folgender Modifier:
		\begin{description}
			\item[\texttt{final}] Sorgt dafür, dass die Variable nur einmal zugewiesen werden kann (zum Beispiel direkt nach oder noch während der Deklaration). Wenn möglich sollte eine Variable immer als \lstinline|final| markiert werden, um versehentliches Überschreiben des Wertes zu verhindern.
		\end{description}
		Handelt es sich bei der Variablen um eine Instanz- oder Klassenvariable, sind zusätzlich folgende Modifier verfügbar:
		\begin{description}
			\item[\texttt{volatile}] Bei der Zuweisung der Variablen geschieht die Zuweisung \textit{atomar}. Dieser Modifier kann nicht mit \lstinline|final| modifiziert werden.
			\item[\texttt{transient}] Bei der Serialisierung einer Instanzvariablen wird dieses Feld nicht serialisiert.
			\item[\(\bullet\)] Sämtliche Sichtbarkeitsmodifizierer (siehe \ref{sec:visibility}).
		\end{description}
		Alle Modifier können wir mit kleinen Einschränkungen beliebig kombinieren.
		
		Beispiel: Eine Definition einer privaten Klassenvariable \texttt{timestamp}, die atomar Zugewiesen werden soll und nicht mit serialisiert werden soll sieht so aus:
		\begin{figure}[H]
			\centering
			\lstinline|private static transient volatile long timestamp;|
		\end{figure}
	% end
	
	\subsubsection{Lokale Variablen, Konstanten, Attribute, Arraykomponenten}
		\todo{Schreiben}
	% end
	
	\subsubsection{Null- und Defaultwerte}
		Klassenvariablen, die nicht \lstinline|final| sind, werden bestimmte Default-Werte zugewiesen (sofern die Variable nicht während der Deklaration direkt zugewiesen wird):
		\begin{table}[H]
			\centering
			\begin{tabular}{l | l}
				\textbf{Typ} & \textbf{Default-Wert} \\ \hline
				\lstinline|byte| & \lstinline|0| \\
				\lstinline|short| & \lstinline|0| \\
				\lstinline|int| & \lstinline|0| \\
				\lstinline|long| & \lstinline|0| \\
				\lstinline|float| & \lstinline|0.0F| \\
				\lstinline|double| & \lstinline|0.0| \\
				\lstinline|boolean| & \lstinline|false| \\
				\lstinline|char| & \lstinline|'\000'| (Null-Byte) \\
				\lstinline|Object| und Unterklassen & \lstinline|null| \\
			\end{tabular}
			\caption{Java: Defaultwerte}
		\end{table}
	% end
% end

\subsection{Zuweisungen}
	\implements{Zuweisungen}{zuweisungen}{Java}
	
	Um eine Variable zuzuweisen, wird folgender Ausdruck verwendet:
	\begin{figure}[H]
		\centering
		\lstinline|<variable> = <ausdruck>;|
	\end{figure}
	Dabei ist der linke Teil \texttt{<variable>} der Name der Variablen, welcher der Wert des Ausdrucks \texttt{<ausdruck>} zugewiesen wird. Der Ausdruck kann dabei beliebig komplex sein.
	
	Wie können den Wert auch zeitgleich mit der Deklaration zuweisen, die Syntax ist dann wie folgt:
	\begin{figure}[H]
		\centering
		\lstinline|<modifier> <typ> <name> = <ausdruck>;|
	\end{figure}

	Eine Besonderheit ist hier, dass der Ausdruck einer normalen Zuweisung den Wert der Zuweisung zurück gibt (das heißt es gilt \texttt{(<variable> = <ausdruck>) == <ausdruck>}).
% end

\subsection{Methodenaufrufe}
	\implements{Methodenaufrufen}{methodenNutzung}{Java}
	
	Der allgemeine Ausdruck, um eine Methode in Java aufzurufen ist:
	\begin{figure}[H]
		\centering
		\lstinline|<objekt>.<methodenname>([parameter], [parameter], ...)|
	\end{figure}
	Der Methodenname muss immer gegeben sein, ebenso wie das Objekt (beziehungsweise bei einer statischen Methode die Klasse), welches/welche das Objekt enthält. Die Parameter müssen gegeben sein, wenn die aufgerufene Methode dies fordert, es gibt aber auch Methoden, die keine Parameter erfordern.
	
	Wir können die Rückgabe der Methode auch einer Variablen zuweisen, die Syntax ist dann wie folgt:
	\begin{figure}[H]
		\centering
		\lstinline|<variable> = <objekt>.<methodenname>([parameter], [parameter], ...)|
	\end{figure}
	Dies ist nur möglich, wenn die Methode einen Rückgabetyp hat, das heißt der Rückgabetyp nicht \lstinline|void| ist.
% end

\subsection{Operatoren}
	\implements{Operatoren}{operatoren}{Java}
	
	\subsubsection{Arithmetik-Operatoren}
		Es existieren die folgenden arithmetischen Operatoren, die allesamt alle primitiven und numerischen Datentypen (\lstinline|byte|, \lstinline|short|, \lstinline|int|, \lstinline|long|, \lstinline|float|, \lstinline|double|) annehmen:
		\begin{table}[H]
			\centering
			\begin{tabular}{c | l | l}
				\textbf{Operator} & \textbf{Syntax}                & \textbf{Beschreibung}                                    \\ \hline
				\texttt{++}       & \texttt{a++}, \texttt{++a}     & \texttt{a} wird um 1 \textit{inkrementiert}.             \\
				\texttt{-{}-}     & \texttt{a-{}-}, \texttt{a-{}-} & \texttt{a} wird um 1 \textit{dekrementiert}.             \\
				\texttt{*}        & \texttt{a * b}                 & \texttt{a} und \texttt{b} werden \textit{multipliziert}. \\
				\texttt{/}        & \texttt{a / b}                 & \texttt{a} wird durch \texttt{b} \textit{dividiert}.     \\
				\texttt{\%}       & \texttt{a \% b}                & Es wird \( \texttt{a} \textbf{ mod } \texttt{b} \) berechnet (d.h. \( \texttt{a} - \big\lfloor \frac{\texttt{a}}{\texttt{b}} \big\rfloor \texttt{b} \)) (\textit{Modulo}). \\
				\texttt{+}        & \texttt{a + b}                 & \texttt{a} und \texttt{b} werden \textit{addiert}.       \\
				\texttt{-}        & \texttt{a - b}                 & \texttt{b} wird von \texttt{a} \textit{subtrahiert}.
			\end{tabular}
		\end{table}
		Bei den Inkrementierungs-/Dekrementierungs-Operatoren ist der Unterschied zwischen den Syntaxen \texttt{a++} und \texttt{++a} (beziehungsweise \texttt{a-{}-} und \texttt{-{}-a}), dass das Ergebnis von ersterem Ausdruck den Wert von \texttt{a} vor der Inkrementierung/Dekrementierung und \texttt{++a}/\texttt{-{}-a} den Wert nach der Inkrementierung/Dekrementierung als Ergebnis liefert (Postfix vs. Prefix Operatoren). Das bedeutet, dass \texttt{a++ == a}, \texttt{a-{}- == a}, \texttt{++a == a + 1} und \texttt{-{}-a == a - 1} gelten.
		
		\paragraph{Kommazahlen und Division}
			Eine Division wird immer als \textit{Ganzzahldivision} durchgeführt, wenn nicht mindestens einer der Parameter eine Fließkommazahl ist. Das bedeutet, dass Nachkommastellen nur berechnet werden, wenn mindestens einer der Parameter ein \lstinline|float| oder \lstinline|double| ist.
			
			Eine Ganzzahldivision von \(a\) und \(b\) entspricht \( \big\lfloor \frac{a}{b} \big\rfloor \), dass heißt, die Nachkommastellen werden abgeschnitten.
		% end
	% end
	
	\subsubsection{Logik- und Vergleichs-Operatoren}
		Es existieren die folgenden logischen Operatoren und Vergleichsoperatoren, die alle als Ergebnis ein \lstinline|boolean| zurück geben.
		\begin{table}[H]
			\centering
			\begin{tabular}{c | l | l | l}
				\textbf{Operator} & \textbf{Syntax}   & \textbf{Parametertyp} & \textbf{Beschreibung}                                         \\ \hline
				   \texttt{<}     & \texttt{a < b}    & primitive Zahl        & Ist \texttt{a} kleiner \texttt{b}?                            \\
				   \texttt{>}     & \texttt{a > b}    & primitive Zahl        & Ist \texttt{a} größer \texttt{b}?                             \\
				   \texttt{<=}    & \texttt{a <= b}   & primitive Zahl        & Ist \texttt{a} kleiner-gleich \texttt{b}?                     \\
				   \texttt{>=}    & \texttt{a >= b}   & primitive Zahl        & Ist \texttt{a} größer-gleich \texttt{b}?                      \\
				   \texttt{==}    & \texttt{a == b}   & Beliebig              & Ist \texttt{a} identisch zu \texttt{b}?                       \\
				   \texttt{!=}    & \texttt{a != b}   & Beliebig              & Ist \texttt{a} nicht identisch zu \texttt{b}?                 \\
				  \texttt{\&\&}   & \texttt{a \&\& b} & Wahrheitswert         & Verknüpft \texttt{a} und \texttt{b} mit einem logischem UND.  \\
				   \texttt{||}    & \texttt{a || b}   & Wahrheitswert         & Verknüpft \texttt{a} und \texttt{b} mit einem logischem ODER. \\
				   \texttt{\^}    & \texttt{a \^{} b} & Wahrheitswert         & Verknüpft \texttt{a} und \texttt{b} mit einem logischem XOR.
			\end{tabular}
		\end{table}
		\textit{Identisch} bedeutet für Zahlen, dass diese bis auf die letzte Nachkommastelle gleich sind. Für Objekte bedeutet dies, dass es ein und das selbe Objekt sind (das heißt, dass die Speicheradresse identisch ist). Eine Änderung auf \texttt{a} ändert somit auch \texttt{b}, wenn \texttt{a == b} gilt (nur bei Objekten!). Aufgrund dessen ist es auch nicht möglich, Strings mit \texttt{==} zu vergleichen, da dies bei Benutzereingaben oder ähnlichem immer \lstinline|false| liefern würde, da die Objekte nur den gleichen Inhalt haben und nicht identisch sind (siehe auch \ref{sec:equals_identity}).
	% end
	
	\subsubsection{Bitlogik-Operatoren}
		Die bitlogischen Operatoren können auf primitive Ganzzahlen (\lstinline|byte|, \lstinline|short|, \lstinline|int|, \lstinline|long|) angewendet werden. Diese wenden die üblichen logischen Verknüpfungen auf Bit-Ebene an, dass heißt, die Zahl wird in Binärdarstellung überführt und die Verknüpfung der Reihe nach auf jedes Bit einzeln angewendet (bei ungleich großen Datentypen werden die fehlenden Stellen bei dem kleineren mit Nullen aufgefüllt). Der Rückgabetyp entspricht immer dem größeren Datentyp. Es existieren die folgenden Operatoren:
		\begin{table}[H]
			\centering
			\begin{tabular}{c | l | l}
				\textbf{Operator} & \textbf{Syntax}      & \textbf{Beschreibung}                                                                               \\ \hline
				  \texttt{<{}<}   & \texttt{a <{}< b}    & Verschiebt die Bits von \texttt{a} um \texttt{b} Stellen nach links.                                \\
				  \texttt{>{}>}   & \texttt{a >{}> b}    & Verschiebt die Bits von \texttt{a} um \texttt{b} Stellen nach rechts.                               \\
				\texttt{>{}>{}>}  & \texttt{a >{}>{}> b} & Verschiebt die Bits von \texttt{a} um \texttt{b} Stellen nach rechts und behält das Vorzeichen bei. \\
				   \texttt{\&}    & \texttt{a \& b}      & Verknüpft die Bits von \texttt{a} und \texttt{b} mit einer UND-Verknüpfung.                         \\
				   \texttt{\^}    & \texttt{a \^{} b}    & Verknüpft die Bits von \texttt{a} und \texttt{b} mit einer XOR-Verknüpfung.                         \\
				   \texttt{|}     & \texttt{a | b}       & Verknüpft die Bits von \texttt{a} und \texttt{b} mit einer ODER-Verknüpfung.
			\end{tabular}
		\end{table}
	% end
	
	\subsubsection{Spezielle Operatoren (\texttt{new}, \texttt{instanceof})}
		\todo{Schreiben}
	% end
	
	\subsubsection{Bindungsstärke der Operatoren}
		\todo{Schreiben}
	% end
	
	\subsubsection{Klammerung}
		\todo{Schreiben}
	% end
% end

\subsection{Rückgabe von Werten}
	\todo{Schreiben}
	
	\paragraph{Sonderfall \texttt{finally}}
		\todo{Schreiben}
	% end
% end

\subsection{Polymorphie}
	\todo{Schreiben}
	
	\subsubsection{Schlüsselwort \lstinline|this|}
		\todo{Schreiben}
	% end
	
	\subsubsection{Schlüsselwort \lstinline|super|}
		\todo{Schreiben}
	% end
% end

\subsection{Implizite und Explizite Typkonvertierung (Casts)}
	\todo{Schreiben}
	
	\subsubsection{Primitive Typen}
		\todo{Schreiben}
	% end
	
	\subsubsection{Wrapper Typen}
		\todo{Schreiben}
	% end
	
	\subsubsection{Objekte (\enquote{Downcast})}
		\todo{Schreiben}
	% end
% end

\subsection{Links-/Rechtsausdrücke}
	\todo{Schreiben}
% end

\subsection{Seiteneffekte}
	\todo{Schreiben}
% end
