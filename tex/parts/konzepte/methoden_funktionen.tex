\introduces{von Methoden}{methoden}

Mit steigender Komplexität der Programme werden wir sehen, dass sich oftmals viele Stellen im Code doppelt, dreifach oder noch öfter zu finden sind. Auch wird ersichtlich, dass ein Programm, welches aus $ >200 $ Zeilen besteht, nicht mehr übersichtlich ist.

Hier können \textit{Methoden} helfen, welche den Code strukturieren.

Eine Methode nimmt Daten entgegen (Eingabe), verarbeitet diese (Verarbeitung) und gibt das Ergebnis aus (Ausgabe). Somit setzen Methoden das EVA-Prinzip der Informatik um und können als Blackbox betrachtet werden, die eine bestimmte Aufgabe (beispielsweise Wurzelziehen) erledigen.

\subsection{Aufbau} \functionalMark \imperativeMark \oopMark
	Wie bereits erwähnt nimmt eine Methode Daten entgegen, verarbeitet diese und gibt das Ergebnis aus (wenn eines berechnet wurde).
	
	Die eingehenden Daten werden über \textit{Parameter} übergeben, im \textit{Körper} verarbeitet und mit einer \textit{Rückgabe} zurück gegeben. Dabei entspricht bei funktionalen Sprachen eine Methode einer Mathematischen Funktion, welche genau eine Sache tut und Werte zurück gibt. Bei imperativer Programmierung ist es möglich, dass Methoden keinen Rückgabewert haben und mehrere Dinge tun können (mehrere Zeilen Code).
	
	Schauen wir uns diese Einzelkomponenten von Methoden nochmals genauer an.

	\subsubsection{Parameter} \functionalMark \imperativeMark \oopMark
		Ein \textit{Parameter} wird von einer Methode spezifiziert (die Anzahl und der Typ der Parameter) und kann innerhalb der Methode wie eine normale Variable (oder in machen Sprachen Konstante) verwendet werden. Sie stellen die Eingabe der Daten in die Methode dar und werden vom Aufrufer übergeben.
		
		Parameter sind auch bekannt aus der Mathematik, beispielsweise das \enquote{\(x\)} in der Funktion \[ f : \mathbb{N} \rightarrow \mathbb{R} : \underline{x} \mapsto x ^ 2 \] wobei \enquote{\(\mathbb{N}\)} den Typ des Parameters festlegt.
		
		\paragraph{Formale Parameter vs. Aktualparameter}
			Wir unterscheiden zwischen den \textit{Formalen Parametern} und den \textit{Aktualen Parametern}.
			
			\begin{itemize}
				\item Die \textit{Formalen Parameter} sind diejenigen Parameter, die bei der Methodendefinition angegeben werden.
				\item Die \textit{Aktualen Parameter} sind diejenigen Parameter, die bei dem Methodenaufruf angegeben werden.
			\end{itemize}
		% end
	% end
	
	\subsubsection{Körper} \functionalMark \imperativeMark \oopMark
		Der Code innerhalb einer Methode wird als \textit{Körper} der Methode bezeichnet. Dieser nutzt die Parameter der Methode, enthält den nötigen Code für die zu erledigende Aufgabe und führt die Rückgabe aus. Er stellt den wichtigsten Teil der Methode dar, denn ohne Code wäre eine Methode sinnfrei.
		
		Wieder als mathematische Funktion betrachtet, kann das \enquote{\( x ^ 2 \)} als Körper der Funktion \[ f : \mathbb{N} \rightarrow \mathbb{R} : x \mapsto \underline{x ^ 2} \] verstanden werden.
	% end
	
	\subsubsection{Rückgabe} \functionalMark \imperativeMark \oopMark
		Jede Methode hat eine \textit{Rückgabe}, welche bei imperativen Sprachen auch leer sein kann (also kein expliziter Rückgabewert). Dies wird meist als \textit{Void} (englisch für \enquote{Nichts}) bezeichnet. Der \textit{Rückgabewert} ist der Wert, den die Methode aus den Parametern berechnet hat und den der Aufrufer erhält. In einer (statisch) typisierten Sprache wird außerdem der Rückgabetyp definiert, mit dem der Aufrufer rechnen kann. Die Rückgabe ist bei einer funktionalen Programmiersprache implizit, das heißt es wird nicht genau angegeben, an welcher Stelle ein Wert zurück gegeben wird. In einer imperativen Programmiersprache erfolgt die Rückgabe explizit und kann auch schon vor vollständigem Ablauf der Methode ausgeführt werden. In diesem Fall bricht die Ausführung der Methode ab. Dies kann zum Beispiels nützlich sein, wenn auf invalide Eingaben (beispielsweise negative Zahlen) geprüft wird.
		
		Erneut als mathematische Funktion \[ f : \underline{\mathbb{N}} \rightarrow \mathbb{R} : x \mapsto x ^ 2 \] betrachtet, kann \enquote{\(\mathbb{R}\)} als Rückgabetyp verstanden werden. Da mathematische Funktionen funktional sind, findet keine explizite Rückgabe statt, sondert es wird einfach das Quadrat von \(x\) zurück gegeben.
	% end
% end

\subsection{Verträge} \functionalMark \imperativeMark \oopMark
	Verträge sind Teil der Dokumentation, siehe Abschnitt \refIntr{vertraege}.
% end

\subsection{Rekursion} \functionalMark \imperativeMark \oopMark
	\introduces{von Rekursion}{rekursion}

	\textbox{Um die Rekursion zu verstehen, muss man zuerst die Rekursion (Siehe \refIntr{rekursion}) verstehen.}
	
	Rekursion bezeichnet ein Paradigma, bei dem sich eine Methode selbst aufruft und damit eine Schleife vermeidet. Dadurch ist es möglich, viele Probleme sehr übersichtlich zu lösen, wodurch der Code lesbarer und damit wartbarer wird. Wenn man es mit der Rekursion allerdings übertreibt, wird der Code sehr schwer verständlich.
	
	Schauen wir uns als Beispiel eine mathematische Definition an, bei der Rekursion eingesetzt wird: Die Fakultät \( n! \) einer natürlichen Zahl \( n \in \mathbb{N} \):
	\begin{equation*}
		n! =
			\begin{cases}
				1                & \text{falls } n = 1 \\
				n \cdot (n - 1)! & \text{sonst}
			\end{cases}
	\end{equation*}
	
	Hier wird im zweiten Fall der Fallunterscheidung Rekursion eingesetzt, indem die Fakultät-Funktion erneut genutzt wird.
	
	\paragraph{Rekursionsanker}
		Der \textit{Rekursionsanker} bezeichnet den Teil der Funktion, der dafür zuständig ist, dass der Methodenaufruf beendet wird. Im obigen Beispiel ist dies der erste Fall der Fallunterscheidung, da dieser die Rekursion abbricht.
		
		Es kann auch mehrere Rekursionsanker geben, die zusammen zum Ende der Rekursion führen.
		
		\subparagraph{Übung}
		In folgendem Beispiel wird die \(n\)-te Fibonacci-Zahl berechnet. Was ist in diesem Fall der Rekursionsanker?
		\begin{equation*}
			\text{Fib}(n) =
				\begin{cases}
					0                                     & \text{falls } n = 0 \\
					1                                     & \text{falls } n = 1 \\
					\text{Fib}(n - 1) + \text{Fib}(n - 2) & \text{sonst}
				\end{cases}
		\end{equation*}
		Dies führt zu der Fibonacci-Folge
		\begin{equation*}
			0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, \cdots
		\end{equation*}
	% end
% end

\subsection{Überladen} \functionalMark \imperativeMark \oopMark
	In den meisten Programmiersprachen ist es möglich, eine mehrere Methoden mit dem gleichen Namen, aber unterschiedlichen Parametern, zu implementieren. Dann wird anhand der Parameter entschieden, welche Methode ausgeführt werden soll. Je nach Sprache ist nur möglich, nach Anzahl der Parameter zu unterscheiden oder auch nach Typ zu unterscheiden (Java, Kotlin, \dots). Andere Sprachen unterstützen Überladung gar nicht (Racket, Python, \dots).
% end

\subsection{Überschreiben} \oopMark
	Im Kontext von objektorientierter Programmierung und Vererbung ist es von Zeit zu Zeit nötig, eine Implementierung einer Funktion von der Oberklasse zu ändern. Hierzu kann die gleiche Methode erneut implementiert werden, welche anschließend die vorherige Implementation ersetzt. Dies wird \textit{Überschreiben} von Methoden genannt. Die meisten Sprachen bieten hier auch die Möglichkeit, explizit die \enquote{alte} Implementierung aus der Oberklasse aufzurufen.
% end
