Wir werden uns in diesem Abschnitt einige abstrakte Konzepte zur objektorientierten Programmierung anschauen.

\subsection{Konzept}
	Das Paradigma der objektorientierten Programmierung haben wir uns bereits im Abschnitt zu Programmierparadigmen (siehe \refIntr{oop}) angeschaut.
	
	In der objektorientierten Programmierung dreht sich also alles um sogenannte \textit{Objekte}. Aber wie bringen wir dem Computer bei, unseren Code als Objekt, beziehungsweise als Objekte, anzusehen? Hierbei stoßen wir auf die Konzepte von Klassen, Methoden, Interfaces und Vererbung. Dies werden wir uns in den folgenden Abschnitten genauer anschauen.
	
	Das Grundlegende Prinzip der Objektorientierung ist, komplexe Sachverhalten wie sie in der Realität auftreten zu vereinfachen und möglichst Realitätsnah abzubilden. Dazu betrachten wir die Programmierung wie die Realität, bei der sich ebenfalls alles um Objekte dreht.
% end

\subsection{Klassen, Objekte und Methoden} \imperativeMark \oopMark
	\introduces{von Klassen, Objekten und Methoden}{classes}
	
	\textit{Klassen} können wir als \enquote{Vorlagen} für \textit{Objekte} ansehen und Objekte realisieren eine Klasse dahingehend, als dass bestimmte Eigenschaften der Klasse mit Werten gefüllt werden. Diese Eigenschaften sind Attribute, die für jedes Objekt getrennt gespeichert und verarbeitet werden und aus Methoden, welche Funktionalitäten zu einer Klasse, beziehungsweise einem Objekt, hinzufügen.
	
	Schauen wir uns ein Beispiel an: Um uns herum sind viele Personen, die wir grob als Klasse \enquote{Mensch} mit dem Attribut \enquote{name} abbilden können. Dann sind Personen wie \enquote{Florian} mit dem Namen \enquote{Florian Kadner} und Fabian mit dem Namen \enquote{Fabian Damken} \textit{Instanzen} dieser Klasse, genannt \textit{Objekte}. Wollen wir nun einem Menschen die Funktionalität \enquote{gehen} hinzufügen, so fügen wir der Klasse \enquote{Mensch} eine Methode \enquote{gehen} hinzu. Damit können wir nun diese Methode auf jedem Menschen aufrufen, zum Beispiel auf Fabian und Florian. Diese laufen nun wild durch die Gegend.
	
	Das fasst alles grob zusammen, was wir abstrakt über Klasse, Objekte und Methoden lernen können. Je nach Programmiersprache gibt es hier noch viele Besonderheiten, die wir uns für Java noch genauer im Abschnitt \refImpl{classes}{Java} anschauen werden.
	
	Schauen wir uns noch kurz an, was es mit \textit{statischen} Attributen/Methoden auf sich hat. Statische Attribute und Methoden \enquote{hängen} direkt an der Klasse und verhalten sich nicht je nach Objekt anders. Das bedeutet, dass auf die Attribute und Methoden auch ohne ein konkretes Objekt zugegriffen werden kann und dass jedes Objekt auf den den selben Wert zugreift wie andere Objekte der gleichen Klasse. An dieser Stelle müssen wir darauf achten, nicht zu viele statische Attribute und Methoden zu verwenden, da hiermit die Objektorientierung wieder ausgehebelt werden kann.
	
	Noch eine kurze Begriffsklärung:
	\begin{description}
		\item[Klasse] Die Vorlage für Objekte. Kann Attribute und Methoden enthalten.
		\item[Objekt] Ein Objekt einer Klasse ist die Realisierung der selbigen mit festgelegten Attributwerten.
		\item[Instanz] Das gleiche wie ein Objekt.
		\item[Instanzvariable] Ein Attribut einer Klasse, welches Instanzspezifisch ist.
		\item[Klassenvariabke] Ein Attribut einer Klasse, welches für alle Instanzen das selbe ist.
		\item[Methode] Ein aufrufbares Stück Code, welches Parameter annimmt, Daten zurück geben kann und auf die Attribute der Klasse/des Objektes zugreifen kann.
		\item[Klassenmethode] Das gleiche wie eine Methode, nur dass die für alle Instanzen gleich ist, ohne Erstellung einer Instanz aufgerufen werden kann und somit auch keinen Zugriff auf die Instanzvariablen hat.
	\end{description}

	\paragraph{UML-Diagramm}
		Eine Klasse wird wie folgt in UML\footnote{Unified Modeling Language, eine Definition von vielen Diagrammtypen. In dem Skript werden wir nur das UML-Klassendiagramm nutzen, weitere Diagramme werden in der Veranstaltung \enquote{Software Engineering} behandelt.} dargestellt:
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				\umlclass{Klassenname}{Attribute}{Methoden}
			\end{tikzpicture}
		\end{figure}
	% end
% end

\subsection{Vererbung} \imperativeMark \oopMark
	\introduces{von Vererbung}{inheritance}

	Klassen und Objekte sind schön und gut, aber betrachten wir folgendes Beispiel: Wir haben die Klassen \enquote{Quadrat} und \enquote{Kreis}, die beide eine Methode \enquote{ausmalen} implementieren. Die Implementierung ist in dem Fall für beide Klassen gleich und wir haben den Code einfach kopiert. Ist die Implementierung nun Fehlerhaft, so müssen wir beide Methoden anpassen und dürfen dies auch nicht vergessen. Hier kommt Vererbung ins Spiel: Wir erstellen eine Oberklasse \enquote{Form}, von der die Klassen \enquote{Quadrat} und \enquote{Kreis} erben. Das bedeutet nun, dass alle Methoden, die in der Klasse \enquote{Form} definiert sind, auch in den Klassen \enquote{Kreis} und \enquote{Quadrat} verfügbar sind. Somit müssen wir die Methode \enquote{ausmalen} nur einmal implementieren.
	
	In den meisten Programmiersprachen ist es nur möglich, von maximal einer Klasse zu erben. Mehrfachvererbung wird auch von einigen Sprachen implementiert, dies erhöht an vielen Stellen allerdings die Komplexität und wurde deshalb in den moderneren Sprachen weg gelassen.
	
	\paragraph{UML-Diagramm}
		Eine Vererbung wird in UML mit einem Pfeil dargestellt, wobei das Pfeilende nicht ausgemalt wird und auf die Klasse zeigt, von der geerbt wird.
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				\umlclass{Oberklasse}{}{+ doIt()}
				\umlclass[below = 1 of Oberklasse]{Unterklasse}{}{}
				
				\umlinherit{Unterklasse}{Oberklasse}
			\end{tikzpicture}
		\end{figure}
	% end
% end

\subsection{Abstrakte Klassen} \imperativeMark \oopMark
	\introduces{von abstrakten Klassen}{abstractclass}

	\textit{Abstrakte Klassen} bieten uns einen Weg, eine Methode zu definieren, aber nicht zu implementieren. Das bedeutet, wir definieren den Namen, die Parameter und den Rückgabetyp einer Methode ohne diese zu implementieren und überlassen es den Unterklassen, die Methode zu implementieren.
	
	Dadurch ist es möglich, eine ebene an Abstraktion zu erreichen, die wir uns am besten an einem Beispiel anschauen: Wir haben die abstrakte Klasse \enquote{Form}, welche die Methode \texttt{flaecheninhalt()} definiert. Diese Methode zur Berechnung des Flächeninhaltes der jeweiligen Form ist Abstrakt und wird von jeder Form (zum Beispiel \enquote{Kreis} oder \enquote{Quadrat}) implementiert. Wir können nun eine Methode \lstinline|double farbverbrauch(Form form, doubl)| entwickeln, welche den Farbverbrauch bei dem Ausmalen der jeweiligen Funktion berechnet. Den Flächeninhalt der Form erhält die Methode dabei durch die vorher definierte abstrakte Methode \texttt{flaecheninhalt()}, die auf der übergebenen Form aufgerufen wird.
	
	Dabei wird immer die Implementierung aufgerufen, die gerade in dem Objekt steht, siehe \refIntr{polymorphy}. Es ist auch möglich, dass eine Oberklasse eine Methode implementiert, welche wiederum andere, abstrakte, Methoden nutzt, die später erst in den Unterklassen implementiert werden\footnote{Dies stellt das }.
	
	\paragraph{UML-Diagramm}
		Abstrakte Methoden werden in UML kursiv gekennzeichnet:
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				\umlclass{Oberklasse}{}{\umlvirt{+ doIt()}}
				\umlclass[below = 1 of Oberklasse]{Unterklasse}{}{+ doIt()}
				
				\umlinherit{Unterklasse}{Oberklasse}
			\end{tikzpicture}
		\end{figure}
	% end
% end

\subsection{Interfaces} \imperativeMark \oopMark
	\introduces{von Interfaces}{interfaces}

	Ein \textit{Interface} ist eine besondere abstrakte Klasse und definiert ausschließlich abstrakte Methoden und kann keine Methoden implementieren. Auch kann eine Klasse in den meisten Sprachen auch mehrere Interfaces \textit{implementieren}. Dadurch können wir feste Schnittstellen definieren und Klassen, welche diese Schnittstellen implementieren und können im Rahmen dieser alle gleich genutzt werden.
	
	Schauen wir uns dies wieder an einem Beispiel aus der Realität an: In Java existiert das Interface \lstinline|Comparable|. Dieses Interface definiert eine einzige Methode \lstinline|int compareTo(Object obj)|, mit der das Objekt, auf dem die Methode aufgerufen wird, mit dem übergebenen Objekt verglichen werden kann. Nun kann jede Klasse, die dieses Interface implementiert ist nun als \enquote{Vergleichbar} markiert und kann zum Beispiel innerhalb von sortierten Listen verwendet werden.\footnote{Hier gibt es auch noch andere Möglichkeiten, wir werden dies im Abschnitt \refImpl{datastruct}{Java} genauer betrachten.}
	
	\paragraph{UML-Diagramm}
		Ein Interface wird in UML besonders mit einem sogenannten \enquote{Stereotyp} hervorgehoben, eine Implementierung wird mit gestrichelten Pfeilen dargestellt:
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				\umlinterface{Interface}{\umlvirt{+ doIt()}}{}
				\umlclass[below = 1 of Interface]{Klasse}{}{+ doIt()}
				
				\umlimpl{Klasse}{Interface}
			\end{tikzpicture}
		\end{figure}
	% end
% end

\subsection{Polymorphie und späte Bindung} \imperativeMark \oopMark
	\introduces{von Polymorphie und später Bindung}{polymorphy}

	Dies ist eines der wichtigsten Eigenschaften bei objektorientierter Programmierung. Polymorphie beschreibt die Eigenschaft, dass im die Implementierung einer Methode aufgerufen wird, die in dem Vererbungsbaum eines Objektes an tiefstmöglicher Stelle steht und nicht zwangsweise die Implementierung aufgerufen wird, die in der referenzierten Klasse vorhanden ist.
	
	Betrachten wir hierzu ein Beispiel, um das Prinzip zu veranschaulichen: Wir haben eine Klasse \enquote{Form} mit einer abstrakten Methode \enquote{gewicht()}, die von den Klassen \enquote{Kreis} und \enquote{Quadrat} überschrieben wird:
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}
			\umlclass{Form}{}{
				\umlvirt{+ gewicht()} \\
			}
			\coordinate [below = of Form] (needle);
			\umlclass[below left = 1 of needle]{Kreis}{}{
				+ gewicht() \\
			}
			\umlclass[below right = 1 of needle]{Quadrat}{}{
				+ gewicht() \\
			}
			
			\umlinherit{needle}{Form}
			\draw (Kreis) |- (needle);
			\draw (Quadrat) |- (needle);
		\end{tikzpicture}
	\end{figure}
	Wenn wir nun an einer Stelle ein Objekte der Klasse \enquote{Form} nutzen und darauf die Methode \texttt{gewicht()} aufrufen, so wird die tiefstmögliche Implementierung aufgerufen.
	
	Das bedeutet, wenn unsere Variable mit dem Typ \enquote{Form} ein Objekt der Klasse \enquote{Kreis} enthält, so wird die Implementierung in \enquote{Kreis} aufgerufen. Wie dieses Verfahren der Polymorphie und später Bindung genau funktioniert, werden wir uns im Abschnitt \refImpl{polymorphy}{Java} zu der Implementierung in Java anschauen.
	
	Damit haben wir nun die wesentlichen abstrakten Konzepte der objektorientierten Programmierung abgearbeitet.
% end
